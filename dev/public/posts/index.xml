<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on l1x/dev</title><link>https://dev.l1x.be/posts/</link><description>Recent content in Posts on l1x/dev</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 08 Mar 2021 20:38:21 +0100</lastBuildDate><atom:link href="https://dev.l1x.be/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Compressing data with Parquet</title><link>https://dev.l1x.be/posts/2021/03/08/compressing-data-with-parquet/</link><pubDate>Mon, 08 Mar 2021 20:38:21 +0100</pubDate><guid>https://dev.l1x.be/posts/2021/03/08/compressing-data-with-parquet/</guid><description>Abstract Many times I see that people use Sqlite for distributing large datasets. When the use case is analytical (OLAP), there are often better options. We are going to investigate how much better we could do if we use something other than Sqlite. To make sure, I love Sqlite and use it a lot when a simple SQL single file database does it. For this particular use case, I think using Parquet is better suited.</description></item><item><title>Compressing AWS S3 logs after getting HackerNewsed</title><link>https://dev.l1x.be/posts/2020/12/20/compressing-aws-s3-logs-after-getting-hackernewsed/</link><pubDate>Sun, 20 Dec 2020 17:23:21 +0100</pubDate><guid>https://dev.l1x.be/posts/2020/12/20/compressing-aws-s3-logs-after-getting-hackernewsed/</guid><description>Abstract One of my previous articles about Firecracker and RPI got posted on HN, and I just realized that many months ago, I enabled logging on the S3 bucket hosting this content. I quickly wanted to peek into the stats, and when I discovered that Athena could not process compressed S3 logs.
I was already working on a larger AWS codebase in F#, so I decided to write a tool that can download the raw logs from S3 and merge all the small files, convert it to Parquet and upload those back.</description></item><item><title>Running ASP.Net web application with Falco on AWS Lambda</title><link>https://dev.l1x.be/posts/2020/12/18/running-asp.net-web-application-with-falco-on-aws-lambda/</link><pubDate>Fri, 18 Dec 2020 13:25:21 +0100</pubDate><guid>https://dev.l1x.be/posts/2020/12/18/running-asp.net-web-application-with-falco-on-aws-lambda/</guid><description>Intro This article has been written by Gabor Gergely (kodfodrasz) as a guest post on this blog. He is the lead engineer of our engineering organization working on F#, AWS and Elm.
We have been using AWS Lambda with F# for a while and have some experience with it. Until now, we opted to use the plain AWS Lambda .Net Runtime provided by Amazon because we value simplicity and code being transparent so we can reason about its operation.</description></item><item><title>Diving into Firecracker with Alpine</title><link>https://dev.l1x.be/posts/2020/12/13/diving-into-firecracker-with-alpine/</link><pubDate>Sun, 13 Dec 2020 23:02:21 +0100</pubDate><guid>https://dev.l1x.be/posts/2020/12/13/diving-into-firecracker-with-alpine/</guid><description>Article series 1st part :: https://dev.l1x.be/posts/2020/11/22/getting-started-with-firecracker-on-raspberry-pi/ 2nd part :: this Intro Last time in the 1st article I briefly introduced Firecracker as a lightweight virtualization/containerization solution for extreme-scale (like AWS Lambda functions). This time around I am going to dig a bit deeper into the API and the management of microVMs. I am going to install Alpine on RPI, install Rust and Python, Docker, get the Linux kernel source and compile a new kernel with minimal config, compile our own Firecracker and then create a new rootfs to be able to boot up a guest.</description></item><item><title>Getting started with Firecracker on Raspberry Pi</title><link>https://dev.l1x.be/posts/2020/11/22/getting-started-with-firecracker-on-raspberry-pi/</link><pubDate>Sun, 22 Nov 2020 14:25:21 +0100</pubDate><guid>https://dev.l1x.be/posts/2020/11/22/getting-started-with-firecracker-on-raspberry-pi/</guid><description>Article Series 1st part :: this 2nd part :: https://dev.l1x.be/posts/2020/12/13/diving-into-firecracker-with-alpine/ Abstract Traditionally services were deployed on bare metal and in the last decades we have seen the rise of virtualisation (running additional operating systems in a operating system process) and lately containerisation (running an operating system process in a separate security context from the rest of processes on the same host). Virtualisation and containerisation offers different levels of isolation by moving some operating system functionality to the guest systems.</description></item><item><title>Why I chose Fsharp for our AWS Lambda project</title><link>https://dev.l1x.be/posts/2020/05/08/why-i-chose-fsharp-for-our-aws-lambda-project/</link><pubDate>Fri, 08 May 2020 14:31:21 +0200</pubDate><guid>https://dev.l1x.be/posts/2020/05/08/why-i-chose-fsharp-for-our-aws-lambda-project/</guid><description>Why I chose Fsharp for our AWS Lambda project The dilema I wanted to create a simple Lambda function to be able to track how our users use the website and the web application without a 3rd party and a ton of external dependencies, especially avoiding 3rd party Javascript and leaking out data to mass surveillance companies. The easiest way is to use a simple tracking 1x1 pixel or beacon that collects just the right amount of information (strictly non-PII).</description></item><item><title>How long will the worldâ€™s uranium supplies last?</title><link>https://dev.l1x.be/posts/2020/05/01/how-long-will-the-worlds-uranium-supplies-last/</link><pubDate>Fri, 01 May 2020 14:31:21 +0200</pubDate><guid>https://dev.l1x.be/posts/2020/05/01/how-long-will-the-worlds-uranium-supplies-last/</guid><description>Basics With a complete combustion or fission, approx. 8 kWh of heat can be generated from 1 kg of coal, approx. 12 kWh from 1 kg of mineral oil and around 24,000,000 kWh from 1 kg of uranium-235. Related to one kilogram, uranium-235 contains two to three million times the energy equivalent of oil or coal. The illustration shows how much coal, oil or natural uranium is required for a certain quantity of electricity.</description></item><item><title>FreeNAS 11.3 upgrade issues</title><link>https://dev.l1x.be/posts/2020/04/29/freenas-11.3-upgrade-issues/</link><pubDate>Wed, 29 Apr 2020 14:31:21 +0200</pubDate><guid>https://dev.l1x.be/posts/2020/04/29/freenas-11.3-upgrade-issues/</guid><description>I have an interesting experience with the latest upgrade of FreeNAS 11.3-U2.1. Applications that were deployed in the jail were gone. After fiddling with iocage (the tool that FreeNAS provides to manage jails) I could restore a previous state where all seems fine and dandy.
Steps to restore list of snapshots iocage snaplist tr -l +-------------------------------------------------------------------------+-----------------------+-------+-------+ | NAME | CREATED | RSIZE | USED | +=========================================================================+=======================+=======+=======+ | fux/iocage/jails/tr/root@ioc_plugin_update_2020-04-29 | Wed Apr 29 14:55 2020 | 799G | 11.</description></item><item><title>Matching binary patterns</title><link>https://dev.l1x.be/posts/2020/04/29/matching-binary-patterns/</link><pubDate>Wed, 29 Apr 2020 14:31:21 +0200</pubDate><guid>https://dev.l1x.be/posts/2020/04/29/matching-binary-patterns/</guid><description>Matching binary patterns In Erlang, it is easy to construct binaries and bitstrings and matching binary patterns. I was running into Mitchell Perilstein&amp;rsquo;s excellent work on NTP with Erlang and I thought I am going to use this to explain how bitstrings and binaries work in Erlang.
Two concepts:
A bitstring is a sequence of zero or more bits, where the number of bits does not need to be divisible by 8.</description></item></channel></rss>