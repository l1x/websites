<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on l1x/dev</title>
    <link>http://dev.l1x.be/posts/</link>
    <description>Recent content in Posts on l1x/dev</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 01 Jun 2020 14:31:21 +0200</lastBuildDate>
    
	<atom:link href="http://dev.l1x.be/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>How long will the world’s uranium supplies last?</title>
      <link>http://dev.l1x.be/posts/2020/06/01/how-long-will-the-worlds-uranium-supplies-last/</link>
      <pubDate>Mon, 01 Jun 2020 14:31:21 +0200</pubDate>
      
      <guid>http://dev.l1x.be/posts/2020/06/01/how-long-will-the-worlds-uranium-supplies-last/</guid>
      <description>How long will the world’s uranium supplies last?
Basics  With a complete combustion or fission, approx. 8 kWh of heat can be generated from 1 kg of coal, approx. 12 kWh from 1 kg of mineral oil and around 24,000,000 kWh from 1 kg of uranium-235. Related to one kilogram, uranium-235 contains two to three million times the energy equivalent of oil or coal. The illustration shows how much coal, oil or natural uranium is required for a certain quantity of electricity.</description>
    </item>
    
    <item>
      <title>Starting with Hugo, the hard way</title>
      <link>http://dev.l1x.be/posts/2020/05/12/starting-with-hugo-the-hard-way/</link>
      <pubDate>Tue, 12 May 2020 14:31:21 +0200</pubDate>
      
      <guid>http://dev.l1x.be/posts/2020/05/12/starting-with-hugo-the-hard-way/</guid>
      <description>After many years on Jekyll I think the time is right to move to Hugo. Hugo is a static site generator written in Go using Liquid templating. After working with Hugo for couple of days, here are the pros and cons.
Pros:
 fast lots of functionality built in  Cons:
 documentation is useless for starters it is not intuitive what is going on most how-to start with using a complex template  Based on these I this it is worth to write up how to get started.</description>
    </item>
    
    <item>
      <title>Why I chose Fsharp for our AWS Lambda project</title>
      <link>http://dev.l1x.be/posts/2020/05/08/why-i-chose-fsharp-for-our-aws-lambda-project/</link>
      <pubDate>Fri, 08 May 2020 14:31:21 +0200</pubDate>
      
      <guid>http://dev.l1x.be/posts/2020/05/08/why-i-chose-fsharp-for-our-aws-lambda-project/</guid>
      <description>Why I chose Fsharp for our AWS Lambda project The dilema I wanted to create a simple Lambda function to be able to track how our users use the website and the web application without a 3rd party and a ton of external dependencies, especially avoiding 3rd party Javascript and leaking out data to mass surveillance companies. The easiest way is to use a simple tracking 1x1 pixel or beacon that collects just the right amount of information (strictly non-PII).</description>
    </item>
    
    <item>
      <title>Matching binary patterns</title>
      <link>http://dev.l1x.be/posts/2020/04/29/matching-binary-patterns/</link>
      <pubDate>Wed, 29 Apr 2020 14:31:21 +0200</pubDate>
      
      <guid>http://dev.l1x.be/posts/2020/04/29/matching-binary-patterns/</guid>
      <description>Matching binary patterns In Erlang, it is easy to construct binaries and bitstrings and matching binary patterns. I was running into Mitchell Perilstein&amp;rsquo;s excellent work on NTP with Erlang and I thought I am going to use this to explain how bitstrings and binaries work in Erlang.
Two concepts:
  A bitstring is a sequence of zero or more bits, where the number of bits does not need to be divisible by 8.</description>
    </item>
    
  </channel>
</rss>