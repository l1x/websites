<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>cloud on l1x/dev</title><link>https://dev.l1x.be/tags/cloud/</link><description>Recent content in cloud on l1x/dev</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 13 Dec 2020 23:02:21 +0100</lastBuildDate><atom:link href="https://dev.l1x.be/tags/cloud/index.xml" rel="self" type="application/rss+xml"/><item><title>Diving into Firecracker with Alpine</title><link>https://dev.l1x.be/posts/2020/12/13/diving-into-firecracker-with-alpine/</link><pubDate>Sun, 13 Dec 2020 23:02:21 +0100</pubDate><guid>https://dev.l1x.be/posts/2020/12/13/diving-into-firecracker-with-alpine/</guid><description>Article series 1st part :: https://dev.l1x.be/posts/2020/11/22/getting-started-with-firecracker-on-raspberry-pi/ 2nd part :: this Intro Last time in the 1st article I briefly introduced Firecracker as a lightweight virtualization/containerization solution for extreme-scale (like AWS Lambda functions). This time around I am going to dig a bit deeper into the API and the management of microVMs. I am going to install Alpine on RPI, install Rust and Python, Docker, get the Linux kernel source and compile a new kernel with minimal config, compile our own Firecracker and then create a new rootfs to be able to boot up a guest.</description></item><item><title>Getting started with Firecracker on Raspberry Pi</title><link>https://dev.l1x.be/posts/2020/11/22/getting-started-with-firecracker-on-raspberry-pi/</link><pubDate>Sun, 22 Nov 2020 14:25:21 +0100</pubDate><guid>https://dev.l1x.be/posts/2020/11/22/getting-started-with-firecracker-on-raspberry-pi/</guid><description>Article Series 1st part :: this 2nd part :: https://dev.l1x.be/posts/2020/12/13/diving-into-firecracker-with-alpine/ Abstract Traditionally services were deployed on bare metal and in the last decades we have seen the rise of virtualisation (running additional operating systems in a operating system process) and lately containerisation (running an operating system process in a separate security context from the rest of processes on the same host). Virtualisation and containerisation offers different levels of isolation by moving some operating system functionality to the guest systems.</description></item><item><title>CloudClamp</title><link>https://dev.l1x.be/projects/cloudclamp/</link><pubDate>Wed, 13 May 2020 14:31:21 +0200</pubDate><guid>https://dev.l1x.be/projects/cloudclamp/</guid><description>CloudClamp Type safe infrastructure as code with the full power of F#.
Why? I am tired of dealing with configuration files and interpreters that has the expresiveness of Go, safetiness of C and performance of Ruby. Illegal configuration must be made impossible by the type system. ADTs are great for this. Compilation has to check as much as possible and using all language features is a must. C# has libraries for pretty much every single vendor out there or it is trivial to implement the lacking support.</description></item><item><title>Data-cat</title><link>https://dev.l1x.be/projects/data-cat/</link><pubDate>Fri, 01 Nov 2019 14:31:21 +0200</pubDate><guid>https://dev.l1x.be/projects/data-cat/</guid><description>Data-cat Deploying DataDog for a large scale infrastructure
Definitions Geographic Regions Stages Applications Geographic Regions Matches the definitions of AWS Regions. It can be used for GCP or on-prem datacenter as well.
Stages Different stages of application deployments, usually: dev, qa, prod.
Applications A service that provides a distinct business functionality.
Goals having all monitors and dashboards in version control having all monitors templated being able to address smaller parts of the infrastructure Implementation 4 files represent the DataDog configuration for the whole infrastructure.</description></item></channel></rss>