<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>l1x/dev</title><link>http://dev.l1x.be/</link><description>Recent content on l1x/dev</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 12 May 2020 22:02:43 +1100</lastBuildDate><atom:link href="http://dev.l1x.be/index.xml" rel="self" type="application/rss+xml"/><item><title>CloudClamp</title><link>http://dev.l1x.be/project/cloudclamp/</link><pubDate>Wed, 13 May 2020 14:31:21 +0200</pubDate><guid>http://dev.l1x.be/project/cloudclamp/</guid><description>CloudClamp</description></item><item><title>Elafi</title><link>http://dev.l1x.be/project/elafi/</link><pubDate>Tue, 12 May 2020 14:31:21 +0200</pubDate><guid>http://dev.l1x.be/project/elafi/</guid><description>Elixir Ads Filter (ελάφι) ελάφι
What is this? Elafi is a DNS proxy that filters out unwanted content by returning 0.0.0.0 to the A and ::/0 to AAAA requests that try to resolve ad/spam/malware domains.
In my home network this is roughly 10 - 30% of traffic depending on the part of the day and what devices are active. I find it outrageous that I have to look at ads on a device that I purchased, using my internet connection that I paid for and spend CPU time (producing CO2) to look at completely irrelevant ads, sometimes even malware installers.</description></item><item><title>About</title><link>http://dev.l1x.be/about/</link><pubDate>Tue, 12 May 2020 22:02:43 +1100</pubDate><guid>http://dev.l1x.be/about/</guid><description>About Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Eget sit amet tellus cras. Integer eget aliquet nibh praesent tristique magna sit amet purus. Velit egestas dui id ornare arcu odio. Pellentesque sit amet porttitor eget. Ut tellus elementum sagittis vitae et leo duis ut. Neque laoreet suspendisse interdum consectetur libero id faucibus nisl tincidunt. Rhoncus mattis rhoncus urna neque viverra.</description></item><item><title>Why I chose Fsharp for our AWS Lambda project</title><link>http://dev.l1x.be/posts/2020/05/08/why-i-chose-fsharp-for-our-aws-lambda-project/</link><pubDate>Fri, 08 May 2020 14:31:21 +0200</pubDate><guid>http://dev.l1x.be/posts/2020/05/08/why-i-chose-fsharp-for-our-aws-lambda-project/</guid><description>Why I chose Fsharp for our AWS Lambda project The dilema I wanted to create a simple Lambda function to be able to track how our users use the website and the web application without a 3rd party and a ton of external dependencies, especially avoiding 3rd party Javascript and leaking out data to mass surveillance companies. The easiest way is to use a simple tracking 1x1 pixel or beacon that collects just the right amount of information (strictly non-PII).</description></item><item><title>Matching binary patterns</title><link>http://dev.l1x.be/posts/2020/04/29/matching-binary-patterns/</link><pubDate>Wed, 29 Apr 2020 14:31:21 +0200</pubDate><guid>http://dev.l1x.be/posts/2020/04/29/matching-binary-patterns/</guid><description>Matching binary patterns In Erlang, it is easy to construct binaries and bitstrings and matching binary patterns. I was running into Mitchell Perilstein&amp;rsquo;s excellent work on NTP with Erlang and I thought I am going to use this to explain how bitstrings and binaries work in Erlang.
Two concepts:
A bitstring is a sequence of zero or more bits, where the number of bits does not need to be divisible by 8.</description></item></channel></rss>