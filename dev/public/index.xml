<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>l1x/dev</title><link>https://dev.l1x.be/</link><description>Recent content on l1x/dev</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 12 May 2020 14:31:21 +0200</lastBuildDate><atom:link href="https://dev.l1x.be/index.xml" rel="self" type="application/rss+xml"/><item><title>Diving into Firecracker with Alpine</title><link>https://dev.l1x.be/posts/2020/12/13/diving-into-firecracker-with-alpine/</link><pubDate>Sun, 13 Dec 2020 23:02:21 +0100</pubDate><guid>https://dev.l1x.be/posts/2020/12/13/diving-into-firecracker-with-alpine/</guid><description>Article series 1st part :: https://dev.l1x.be/posts/2020/11/22/getting-started-with-firecracker-on-raspberry-pi/ 2nd part :: this Intro Last time in the 1st article I briefly introduced Firecracker as a lightweight virtualization / continerization solution for extreme scale (like AWS Lambda functions). This time around I am going to dig a bit deeper into the API and the management of microVMs. I am going to install Alpine on RPI, install Rust and Python, Docker, get the Linux kernel source and compile a new kernel with minimal config, compile our own Firecracker and then create a new rootfs to be able to boot up a guest.</description></item><item><title>Getting started with Firecracker on Raspberry Pi</title><link>https://dev.l1x.be/posts/2020/11/22/getting-started-with-firecracker-on-raspberry-pi/</link><pubDate>Sun, 22 Nov 2020 14:25:21 +0100</pubDate><guid>https://dev.l1x.be/posts/2020/11/22/getting-started-with-firecracker-on-raspberry-pi/</guid><description>Article Series 1st part :: this 2nd part :: https://dev.l1x.be/posts/2020/12/13/diving-into-firecracker-with-alpine/ Abstract Traditionally services were deployed on bare metal and in the last decades we have seen the rise of virtualisation (running additional operating systems in a operating system process) and lately containerisation (running an operating system process in a separate security context from the rest of processes on the same host). Virtualisation and containerisation offers different levels of isolation by moving some operating system functionality to the guest systems.</description></item><item><title>CloudClamp</title><link>https://dev.l1x.be/projects/cloudclamp/</link><pubDate>Wed, 13 May 2020 14:31:21 +0200</pubDate><guid>https://dev.l1x.be/projects/cloudclamp/</guid><description>CloudClamp Type safe infrastructure as code with the full power of F#.
Why? I am tired of dealing with configuration files and interpreters that has the expresiveness of Go, safetiness of C and performance of Ruby. Illegal configuration must be made impossible by the type system. ADTs are great for this. Compilation has to check as much as possible and using all language features is a must. C# has libraries for pretty much every single vendor out there or it is trivial to implement the lacking support.</description></item><item><title>Elafi</title><link>https://dev.l1x.be/projects/elafi/</link><pubDate>Tue, 12 May 2020 14:31:21 +0200</pubDate><guid>https://dev.l1x.be/projects/elafi/</guid><description>Elixir Ads Filter (ελάφι) ελάφι
What is this? Elafi is a DNS proxy that filters out unwanted content by returning 0.0.0.0 to the A and ::/0 to AAAA requests that try to resolve ad/spam/malware domains.
In my home network this is roughly 10 - 30% of traffic depending on the part of the day and what devices are active. I find it outrageous that I have to look at ads on a device that I purchased, using my internet connection that I paid for and spend CPU time (producing CO2) to look at completely irrelevant ads, sometimes even malware installers.</description></item><item><title>About</title><link>https://dev.l1x.be/about/</link><pubDate>Tue, 12 May 2020 22:02:43 +1100</pubDate><guid>https://dev.l1x.be/about/</guid><description>About Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Eget sit amet tellus cras. Integer eget aliquet nibh praesent tristique magna sit amet purus. Velit egestas dui id ornare arcu odio. Pellentesque sit amet porttitor eget. Ut tellus elementum sagittis vitae et leo duis ut. Neque laoreet suspendisse interdum consectetur libero id faucibus nisl tincidunt. Rhoncus mattis rhoncus urna neque viverra.</description></item><item><title>Why I chose Fsharp for our AWS Lambda project</title><link>https://dev.l1x.be/posts/2020/05/08/why-i-chose-fsharp-for-our-aws-lambda-project/</link><pubDate>Fri, 08 May 2020 14:31:21 +0200</pubDate><guid>https://dev.l1x.be/posts/2020/05/08/why-i-chose-fsharp-for-our-aws-lambda-project/</guid><description>Why I chose Fsharp for our AWS Lambda project The dilema I wanted to create a simple Lambda function to be able to track how our users use the website and the web application without a 3rd party and a ton of external dependencies, especially avoiding 3rd party Javascript and leaking out data to mass surveillance companies. The easiest way is to use a simple tracking 1x1 pixel or beacon that collects just the right amount of information (strictly non-PII).</description></item><item><title>How long will the world’s uranium supplies last?</title><link>https://dev.l1x.be/posts/2020/05/01/how-long-will-the-worlds-uranium-supplies-last/</link><pubDate>Fri, 01 May 2020 14:31:21 +0200</pubDate><guid>https://dev.l1x.be/posts/2020/05/01/how-long-will-the-worlds-uranium-supplies-last/</guid><description>Basics With a complete combustion or fission, approx. 8 kWh of heat can be generated from 1 kg of coal, approx. 12 kWh from 1 kg of mineral oil and around 24,000,000 kWh from 1 kg of uranium-235. Related to one kilogram, uranium-235 contains two to three million times the energy equivalent of oil or coal. The illustration shows how much coal, oil or natural uranium is required for a certain quantity of electricity.</description></item><item><title>FreeNAS 11.3 upgrade issues</title><link>https://dev.l1x.be/posts/2020/04/29/freenas-11.3-upgrade-issues/</link><pubDate>Wed, 29 Apr 2020 14:31:21 +0200</pubDate><guid>https://dev.l1x.be/posts/2020/04/29/freenas-11.3-upgrade-issues/</guid><description>I have an interesting experience with the latest upgrade of FreeNAS 11.3-U2.1. Applications that were deployed in the jail were gone. After fiddling with iocage (the tool that FreeNAS provides to manage jails) I could restore a previous state where all seems fine and dandy.
Steps to restore list of snapshots iocage snaplist tr -l +-------------------------------------------------------------------------+-----------------------+-------+-------+ | NAME | CREATED | RSIZE | USED | +=========================================================================+=======================+=======+=======+ | fux/iocage/jails/tr/root@ioc_plugin_update_2020-04-29 | Wed Apr 29 14:55 2020 | 799G | 11.</description></item><item><title>Matching binary patterns</title><link>https://dev.l1x.be/posts/2020/04/29/matching-binary-patterns/</link><pubDate>Wed, 29 Apr 2020 14:31:21 +0200</pubDate><guid>https://dev.l1x.be/posts/2020/04/29/matching-binary-patterns/</guid><description>Matching binary patterns In Erlang, it is easy to construct binaries and bitstrings and matching binary patterns. I was running into Mitchell Perilstein&amp;rsquo;s excellent work on NTP with Erlang and I thought I am going to use this to explain how bitstrings and binaries work in Erlang.
Two concepts:
A bitstring is a sequence of zero or more bits, where the number of bits does not need to be divisible by 8.</description></item><item><title>Data-cat</title><link>https://dev.l1x.be/projects/data-cat/</link><pubDate>Fri, 01 Nov 2019 14:31:21 +0200</pubDate><guid>https://dev.l1x.be/projects/data-cat/</guid><description>Data-cat Deploying DataDog for a large scale infrastructure
Definitions Geographic Regions Stages Applications Geographic Regions Matches the definitions of AWS Regions. It can be used for GCP or on-prem datacenter as well.
Stages Different stages of application deployments, usually: dev, qa, prod.
Applications A service that provides a distinct business functionality.
Goals having all monitors and dashboards in version control having all monitors templated being able to address smaller parts of the infrastructure Implementation 4 files represent the DataDog configuration for the whole infrastructure.</description></item></channel></rss>